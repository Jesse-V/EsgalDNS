
#include "utils.hpp"
#include <botan/pem.h>
#include <cstdio>
#include <iostream>


//https://stackoverflow.com/questions/6855115/byte-array-to-int-c
uint32_t Utils::arrayToUInt32(const uint8_t* byteArray, int32_t offset)
{
   return *reinterpret_cast<const uint32_t*>(&byteArray[offset]);
}



char* Utils::getAsHex(const uint8_t* data, int len)
{
   char* hexStr = new char[len * 2 + 3];
   hexStr[0] = '0';
   hexStr[1] = 'x';
   for (int i = 0; i < len; i++)
      sprintf(&hexStr[i * 2 + 2], "%02x", data[i]);
   return hexStr;
}



bool Utils::isPowerOfTwo(unsigned int x)
{ //glibc method of checking
   return ((x != 0) && !(x & (x - 1)));
}



//https://stackoverflow.com/questions/1494399/how-do-i-search-find-and-replace-in-a-standard-string
void Utils::stringReplace(std::string& str, const std::string& find,
   const std::string& replace)
{
   size_t pos = 0;
   while ((pos = str.find(find, pos)) != std::string::npos)
   {
      str.replace(pos, find.length(), replace);
      pos += replace.length();
   }
}



//https://stackoverflow.com/questions/874134/
bool Utils::strEndsWith(const std::string& str, const std::string& ending)
{
   if (str.length() >= ending.length())
      return (0 == str.compare (str.length() - ending.length(), ending.length(), ending));
   else
      return false;
}



Botan::RSA_PrivateKey* Utils::loadKey(const char* filename, Botan::RandomNumberGenerator& rng)
{
   try
   {
      //attempt reading key as standardized PKCS8 format
      std::cout << "Opening " << filename << " as PKCS8..." << std::endl;
      auto pvtKey = Botan::PKCS8::load_key(filename, rng);
      auto rsaKey = dynamic_cast<Botan::RSA_PrivateKey*>(pvtKey);
      if (!rsaKey)
         throw std::invalid_argument("The loaded key is not a RSA key!");
      return rsaKey;
   }
   catch (Botan::Decoding_Error& de)
   {
      std::cerr << de.what() << std::endl;
      std::cerr << "  " << filename << " may not be PKCS8-formatted, and likely has been generated by OpenSSL." << std::endl;
      //std::cerr << "  \"openssl pkcs8 -topk8 -nocrypt -in " << filename << "\" will convert the key into PKCS8." << std::endl;

      //if PKCS8 decoding fails, try manual decoding of OpenSSL's format
      std::cout << "Attempting manual decoding..." << std::endl;
      return Utils::loadOpenSSLRSA(filename, rng);
   }

   return NULL;
}



//http://botan.randombit.net/faq.html#how-do-i-load-this-key-generated-by-openssl-into-botan
//http://lists.randombit.net/pipermail/botan-devel/2010-June/001157.html
//http://lists.randombit.net/pipermail/botan-devel/attachments/20100611/1d8d870a/attachment.cpp
Botan::RSA_PrivateKey* Utils::loadOpenSSLRSA(const char* filename, Botan::RandomNumberGenerator& rng)
{
   Botan::DataSource_Stream in(filename);

   Botan::DataSource_Memory key_bits(
      Botan::PEM_Code::decode_check_label(in, "RSA PRIVATE KEY"));

   //Botan::u32bit version;
   size_t version;
   Botan::BigInt n, e, d, p, q;

   Botan::BER_Decoder(key_bits)
      .start_cons(Botan::SEQUENCE)
      .decode(version)
      .decode(n).decode(e).decode(d).decode(p).decode(q);

   if(version != 0)
     return NULL;

   return new Botan::RSA_PrivateKey(rng, p, q, e, d, n);
}
